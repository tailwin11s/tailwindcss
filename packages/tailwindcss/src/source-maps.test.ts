import remapping from '@ampproject/remapping'
import MagicString, { Bundle } from 'magic-string'
import { SourceMapConsumer, type RawSourceMap } from 'source-map-js'
import { expect, test } from 'vitest'
import { compile } from '.'
import { toCss, type Range } from './ast'
import * as CSS from './css-parser'

function run(rawCss: string, candidates: string[] = []) {
  let source = new MagicString(rawCss)

  let bundle = new Bundle()

  bundle.addSource({
    filename: 'source.css',
    content: source,
  })

  let originalMap = Object.assign(
    bundle.generateDecodedMap({
      hires: 'boundary',
      file: 'source.css.map',
      includeContent: true,
    }),
    {
      version: 3 as const,
    },
  )

  let compiler = compile(source.toString(), { map: true })

  let css = compiler.build(candidates)
  let map = compiler.buildSourceMap()

  let combined = remapping([map as any, originalMap], () => null)

  let sources = combined.sources
  let annotations = annotatedMappings(map)

  return { css, map, sources, annotations }
}

test('source locations are tracked during parsing and serializing', async () => {
  let ast = CSS.parse(`.foo { color: red; }`, true)
  toCss(ast, true)

  if (ast[0].kind !== 'rule') throw new Error('Expected a rule')

  let src = annotatedLocations({
    selector: ast[0].source[0],
    decl: ast[0].nodes[0].source[0],
  })

  let dst = annotatedLocations({
    selector: ast[0].destination[0],
    decl: ast[0].nodes[0].destination[0],
  })

  expect(src.selector).toEqual('1:1-1:5')
  expect(dst.selector).toEqual('1:1-1:5')

  expect(src.decl).toEqual('1:8-1:18')
  expect(dst.decl).toEqual('2:3-2:13')
})

test('utilities have source maps pointing to the utilities node', async () => {
  let { sources, annotations } = run(`@tailwind utilities;`, [
    //
    'underline',
  ])

  // All CSS generated by Tailwind CSS should be annotated with source maps
  // And always be able to point to the original source file
  expect(sources).toEqual(['source.css'])
  expect(sources.length).toBe(1)

  expect(annotations).toEqual([
    //
    '1:1-11 <- 1:1-20',
    '2:3-34 <- 1:1-20',
  ])
})

test('@apply generates source maps', async () => {
  let { sources, annotations } = run(`.foo {
  color: blue;
  @apply text-[#000] hover:text-[#f00];
  @apply underline;
  color: red;
}`)

  // All CSS generated by Tailwind CSS should be annotated with source maps
  // And always be able to point to the original source file
  expect(sources).toEqual(['source.css'])
  expect(sources.length).toBe(1)

  expect(annotations).toEqual([
    '1:1-5 <- 1:1-5',
    '2:3-14 <- 2:3-14',
    '3:3-14 <- 3:3-39',
    '4:3-10 <- 3:3-39',
    '5:5-16 <- 3:3-39',
    '7:3-34 <- 4:3-19',
    '8:3-13 <- 5:3-13',
  ])
})

test('license comments preserve source locations', async () => {
  let { sources, annotations } = run(`/*! some comment */`)

  // All CSS generated by Tailwind CSS should be annotated with source maps
  // And always be able to point to the original source file
  expect(sources).toEqual(['source.css'])
  expect(sources.length).toBe(1)

  expect(annotations).toEqual(['1:1-19 <- 1:1-19'])
})

test('license comments with new lines preserve source locations', async () => {
  let { sources, annotations, css } = run(`/*! some \n comment */`)

  // All CSS generated by Tailwind CSS should be annotated with source maps
  // And always be able to point to the original source file
  expect(sources).toEqual(['source.css'])
  expect(sources.length).toBe(1)

  expect(annotations).toEqual(['1:1 <- 1:1', '2:11 <- 2:11'])
})

/**
 * An string annotation that represents one or more source locations
 */
function annotatedLocations<T extends string>(map: Record<T, Range>): Record<T, string> {
  let res: Record<string, string> = {} as any

  for (let key in map) {
    let range = map[key]
    res[key] = `${range.start.line}:${range.start.column}-${range.end.line}:${range.end.column}`
  }

  return res
}

/**
 * An string annotation that represents a source map
 *
 * It's not meant to be exhaustive just enough to
 * verify that the source map is working and that
 * lines are mapped back to the original source
 *
 * Including when using @apply with multiple classes
 */
function annotatedMappings(map: RawSourceMap) {
  const smc = new SourceMapConsumer(map)
  const annotations: Record<
    number,
    {
      original: { start: [number, number]; end: [number, number] }
      generated: { start: [number, number]; end: [number, number] }
    }
  > = {}

  smc.eachMapping((mapping) => {
    let annotation = (annotations[mapping.generatedLine] = annotations[mapping.generatedLine] || {
      ...mapping,

      original: {
        start: [mapping.originalLine, mapping.originalColumn],
        end: [mapping.originalLine, mapping.originalColumn],
      },

      generated: {
        start: [mapping.generatedLine, mapping.generatedColumn],
        end: [mapping.generatedLine, mapping.generatedColumn],
      },
    })

    annotation.generated.end[0] = mapping.generatedLine
    annotation.generated.end[1] = mapping.generatedColumn

    annotation.original.end[0] = mapping.originalLine
    annotation.original.end[1] = mapping.originalColumn
  })

  return Object.values(annotations).map((annotation) => {
    return `${formatRange(annotation.generated)} <- ${formatRange(annotation.original)}`
  })
}

function formatRange(range: { start: [number, number]; end: [number, number] }) {
  if (range.start[0] === range.end[0]) {
    // This range is on the same line
    // and the columns are the same
    if (range.start[1] === range.end[1]) {
      return `${range.start[0]}:${range.start[1]}`
    }

    // This range is on the same line
    // but the columns are different
    return `${range.start[0]}:${range.start[1]}-${range.end[1]}`
  }

  // This range spans multiple lines
  return `${range.start[0]}:${range.start[1]}-${range.end[0]}:${range.end[1]}`
}
